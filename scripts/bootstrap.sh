#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)
REPORT=0
PROMPT_SECRETS=0
CHECK_ONLY=0

usage() {
  cat <<'USAGE'
Usage: ./scripts/bootstrap.sh [--prompt-secrets] [--report] [--check]

Options:
  --prompt-secrets  Prompt for environment values instead of applying defaults silently.
  --report          Generate docs/ENVIRONMENT.md and exit (no workspace mutations).
  --check           Skip .env creation and directory setup; only run dependency checks.
  -h, --help        Show this help message.
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --prompt-secrets)
      PROMPT_SECRETS=1
      shift
      ;;
    --report)
      REPORT=1
      shift
      ;;
    --check)
      CHECK_ONLY=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

# Helper: safe command detection
_detect() {
  local cmd=$1
  shift || true
  if command -v "$cmd" >/dev/null 2>&1; then
    "$cmd" "$@"
    return 0
  fi
  return 1
}

# Helper: ensure .env entry exists with optional prompting
ensure_env_entry() {
  local path=$1
  local key=$2
  local default_value=$3
  local comment=$4
  local prompt_flag=$5

  [[ -f "$path" ]] || return 1

  if ! grep -qE "^\s*${key}=" "$path"; then
    if [[ -n "$comment" ]]; then
      printf '# %s\n' "$comment" >>"$path"
    fi
    printf '%s=%s\n' "$key" "$default_value" >>"$path"
    printf 'Added %s to %s (default applied).\n' "$key" "$(basename "$path")"
    printf '%s' "$default_value"
    return 0
  fi

  local line
  line=$(grep -nE "^\s*${key}=" "$path" | head -n1)
  local lineno=${line%%:*}
  local current_value
  current_value=$(sed -n "${lineno}p" "$path" | cut -d'=' -f2-)
  local value_to_set="$current_value"
  local needs_write=0

  if [[ -z "${current_value// }" ]]; then
    value_to_set="$default_value"
    if [[ "$prompt_flag" -eq 1 ]]; then
      read -r -p "Value for ${key} (Enter to keep default '${default_value}'): " input || true
      if [[ -n "${input:-}" ]]; then
        value_to_set="$input"
      fi
    fi
    needs_write=1
  elif [[ "$prompt_flag" -eq 1 ]]; then
    read -r -p "Update ${key}? Current value '${current_value}' (Enter to keep): " input || true
    if [[ -n "${input:-}" ]]; then
      value_to_set="$input"
      needs_write=1
    fi
  fi

  if [[ "$needs_write" -eq 1 ]]; then
    local tmp
    tmp=$(mktemp "${path}.tmp.XXXXXX")
    local replaced=0
    while IFS= read -r line || [[ -n "$line" ]]; do
      if [[ $replaced -eq 0 && "$line" =~ ^[[:space:]]*${key}= ]]; then
        printf '%s=%s\n' "$key" "$value_to_set" >>"$tmp"
        replaced=1
      else
        printf '%s\n' "$line" >>"$tmp"
      fi
    done <"$path"
    mv "$tmp" "$path"
    printf 'Updated %s in %s.\n' "$key" "$(basename "$path")"
  fi

  printf '%s' "$value_to_set"
}

# Environment report mode (no other actions performed)
if [[ "$REPORT" -eq 1 ]]; then
  env_path="$ROOT_DIR/docs/ENVIRONMENT.md"
  os_name="Unknown"
  if [[ -f /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    os_name=${PRETTY_NAME:-$NAME}
  elif _detect sw_vers >/dev/null 2>&1; then
    os_name=$(_detect sw_vers -productName)" "$(_detect sw_vers -productVersion)
  else
    os_name=$(uname -sr)
  fi

  architecture=$(uname -m 2>/dev/null || echo "Unknown")
  shell_name=${SHELL:-$0}
  bash_version=${BASH_VERSION:-"N/A"}

  {
    printf '# Environment Report\n\n'
    printf '*Generated by scripts/bootstrap.sh --report*\n\n'
    printf '- OS: %s\n' "$os_name"
    printf '- Kernel: %s\n' "$(uname -sr 2>/dev/null || echo "Unknown")"
    printf '- Architecture: %s\n' "$architecture"
    printf '- Shell: %s\n' "$shell_name"
    printf '- Bash: %s\n' "$bash_version"
    for entry in \
      "Git|git|--version" \
      "Docker|docker|--version" \
      "Docker Compose|docker|compose version" \
      "PowerShell (pwsh)|pwsh|--version" \
      "Python|python|--version" \
      "Node|node|-v" \
      "npm|npm|-v" \
      "dotnet|dotnet|--info" \
    ; do
      IFS='|' read -r label cmd args <<<"$entry"
      local_args=()
      if [[ -n "${args:-}" ]]; then
        read -r -a local_args <<<"$args"
      fi
      if command -v "$cmd" >/dev/null 2>&1; then
        if output=$("$cmd" "${local_args[@]}" 2>/dev/null); then
          first_line=$(printf '%s\n' "$output" | head -n1)
          printf '- %s: %s\n' "$label" "${first_line:-Detected}"
        else
          printf '- %s: Detected (command failed)\n' "$label"
        fi
      else
        printf '- %s: Not detected\n' "$label"
      fi
    done
  } >"$env_path"

  printf 'Wrote %s\n' "$env_path"
  exit 0
fi

# Workspace mutation (unless --check)
if [[ "$CHECK_ONLY" -eq 0 ]]; then
  env_sample="$ROOT_DIR/.env.example"
  env_local="$ROOT_DIR/.env"
  if [[ -f "$env_sample" && ! -f "$env_local" ]]; then
    cp "$env_sample" "$env_local"
    printf 'Created .env from .env.example\n'
  fi

  if [[ -f "$env_local" ]]; then
    ensure_env_entry \
      "$env_local" \
      'OLLAMA_API_KEY' \
      'ollama-local' \
      'Dummy key required by Codex CLI workflows when proxying to local Ollama. Replace with a real token if bridging to remote services.' \
      "$PROMPT_SECRETS" >/dev/null || true
  else
    printf 'WARNING: .env not found; create it manually or rerun bootstrap after adding .env.example.\n'
  fi

  for dir in data models; do
    target="$ROOT_DIR/$dir"
    if [[ ! -d "$target" ]]; then
      mkdir -p "$target"
    fi
  done
else
  printf 'Skipping .env and directory setup (--check enabled).\n'
fi

# Dependency surface check
check_dependency() {
  local entry=$1
  local name cmd arg_string requirement
  IFS='|' read -r name cmd arg_string requirement <<<"$entry"
  local args=()
  if [[ -n "${arg_string:-}" ]]; then
    read -r -a args <<<"$arg_string"
  fi

  if command -v "$cmd" >/dev/null 2>&1; then
    local output
    if output=$("$cmd" "${args[@]}" 2>/dev/null); then
      local first_line
      first_line=$(printf '%s\n' "$output" | head -n1)
      if [[ -n "$first_line" ]]; then
        printf 'Detected %s: %s\n' "$name" "$first_line"
      else
        printf 'Detected %s (no version output).\n' "$name"
      fi
    else
      local status=$?
      printf 'WARNING: %s command exists but "%s %s" failed (exit %s).\n' "$name" "$cmd" "${arg_string}" "$status"
    fi
  else
    if [[ "$requirement" == "required" ]]; then
      printf 'WARNING: %s not detected. Install it before running compose operations.\n' "$name"
    else
      printf 'WARNING: Optional tool missing: %s. Install to unlock related workflows.\n' "$name"
    fi
  fi
}

for dep in \
  "Docker|docker|--version|required" \
  "Docker Compose|docker|compose version|required" \
  "PowerShell (pwsh)|pwsh|--version|optional" \
  "Codex CLI|codex|--version|optional" \
; do
  check_dependency "$dep"
done

echo "Bootstrap complete. Use scripts/compose.ps1 or scripts/bootstrap.sh to manage the stack."
